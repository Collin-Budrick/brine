use bevy::{prelude::*, render::renderer::RenderDevice};
use std::collections::HashMap;

use brine_asset::TextureKey;

use crate::texture::{PendingAtlas, TextureAtlas};

const PLACEHOLDER_PATH: &str = "placeholder.png";

#[derive(Debug, Resource)]
pub struct TextureManager {
    /// Strong handle to a placeholder texture.
    placeholder_texture: Handle<Image>,

    /// The largest texture size allowed by the rendering backend.
    max_texture_size: u32,

    /// A strong handle to each of the texture atlases generated by calls to
    /// `stitch_atlas`.
    atlases: Vec<Handle<TextureAtlas>>,

    /// Mapping from texture key to index into the `atlases` list.
    key_to_atlas: HashMap<TextureKey, usize>,

    /// List of atlases that are waiting for their textures to be loaded.
    pending_atlases: Vec<PendingAtlas>,
}

impl TextureManager {
    pub fn new(placeholder_texture: Handle<Image>, max_texture_size: u32) -> Self {
        Self {
            placeholder_texture,
            max_texture_size,
            atlases: Default::default(),
            key_to_atlas: Default::default(),
            pending_atlases: Default::default(),
        }
    }

    /// Returns a handle to a texture atlas that contains the given texture.
    ///
    /// Returns `None` if the given texture is not contained in any atlas.
    pub fn get_atlas(&self, texture: TextureKey) -> Option<Handle<TextureAtlas>> {
        self.key_to_atlas
            .get(&texture)
            .map(|index| self.atlases[*index].clone())
    }

    /// Returns a handle that will eventually be populated with a stitched
    /// texture atlas composed of the given textures.
    ///
    /// The textures need not be loaded at the time of calling this method.
    pub fn create_atlas<T>(
        &mut self,
        atlases: &Assets<TextureAtlas>,
        textures: T,
    ) -> Handle<TextureAtlas>
    where
        T: IntoIterator<Item = (TextureKey, Handle<Image>)>,
    {
        let textures: Vec<_> = textures.into_iter().collect();

        debug!("Texture atlas requested for {} textures", textures.len());

        let handle = atlases.reserve_handle();

        let pending_atlas = PendingAtlas { handle: handle.clone(), textures };
        self.pending_atlases.push(pending_atlas);

        handle
    }

    pub fn atlases(&self) -> impl Iterator<Item = &Handle<TextureAtlas>> {
        self.atlases.iter()
    }

    pub fn try_stitch_pending_atlases(
        &mut self,
        textures: &mut Assets<Image>,
        atlases: &mut Assets<TextureAtlas>,
    ) {
        if !textures.contains(&self.placeholder_texture) {
            return;
        }

        let mut remaining_pending = Vec::new();
        let mut new_pending = Vec::new();

        // Take ownership of the pending atlas list so we can borrow `self` again when
        // registering completed atlases without tripping the borrow checker.
        let pending = std::mem::take(&mut self.pending_atlases);
        for pending_atlas in pending {
            if !pending_atlas.all_textures_loaded(textures) {
                remaining_pending.push(pending_atlas);
                continue;
            }

            let atlas_handle = pending_atlas.handle.clone();
            match TextureAtlas::stitch(
                textures,
                pending_atlas
                    .textures
                    .iter()
                    .map(|(key, handle)| (*key, handle)),
                &self.placeholder_texture,
                self.max_texture_size,
            ) {
                Ok(atlas) => {
                    self.register_atlas(atlas_handle, atlas, atlases);
                }
                Err(bevy::image::TextureAtlasBuilderError::NotEnoughSpace)
                    if pending_atlas.textures.len() > 1 =>
                {
                    debug!(
                        texture_count = pending_atlas.textures.len(),
                        "Splitting oversized atlas request into smaller batches"
                    );

                    let mid = pending_atlas.textures.len() / 2;
                    let (left, right) = pending_atlas.textures.split_at(mid);

                    let mut chunk_handles = Vec::with_capacity(2);
                    chunk_handles.push(atlas_handle);
                    chunk_handles.push(atlases.reserve_handle());

                    for (chunk, handle) in [left, right].into_iter().zip(chunk_handles) {
                        new_pending.push(PendingAtlas {
                            handle,
                            textures: chunk.to_vec(),
                        });
                    }
                }
                Err(err) => {
                    warn!(
                        error = %err,
                        texture_count = pending_atlas.textures.len(),
                        "Failed to stitch atlas, falling back to placeholder texture"
                    );

                    let atlas = TextureAtlas::placeholder_only(
                        &self.placeholder_texture,
                        pending_atlas.textures.iter().map(|(key, _)| *key),
                    );
                    self.register_atlas(atlas_handle, atlas, atlases);
                }
            }
        }

        remaining_pending.extend(new_pending);
        self.pending_atlases = remaining_pending;
    }

    fn register_atlas(
        &mut self,
        handle: Handle<TextureAtlas>,
        atlas: TextureAtlas,
        atlases: &mut Assets<TextureAtlas>,
    ) {
        let index = self.atlases.len();
        for texture_key in atlas.regions.keys() {
            self.key_to_atlas.insert(*texture_key, index);
        }

        atlases.insert(handle.id(), atlas).unwrap();
        self.atlases.push(handle);
    }
}

impl FromWorld for TextureManager {
    fn from_world(world: &mut World) -> Self {
        let asset_server = world.get_resource::<AssetServer>().unwrap();
        let placeholder_texture = asset_server.load(PLACEHOLDER_PATH);

        let max_texture_size = world
            .get_resource::<RenderDevice>()
            .map(|device| device.limits().max_texture_dimension_2d)
            .unwrap_or(4096);

        Self::new(placeholder_texture, max_texture_size)
    }
}

pub struct TextureManagerPlugin;

impl Plugin for TextureManagerPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<TextureManager>();
        app.init_asset::<TextureAtlas>();
        app.add_systems(Update, stitch_pending_atlases);
    }
}

fn stitch_pending_atlases(
    mut manager: ResMut<TextureManager>,
    mut textures: ResMut<Assets<Image>>,
    mut atlases: ResMut<Assets<TextureAtlas>>,
) {
    manager.try_stitch_pending_atlases(&mut *textures, &mut *atlases);
}
