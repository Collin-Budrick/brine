use std::collections::{hash_map::Entry, HashMap};

use bevy::{
    asset::{AssetPath, LoadState},
    prelude::*,
};
use bevy_image::{TextureAtlasBuilder, TextureAtlasLayout, TextureAtlasSources};

use brine_data::blocks::BlockStateId;

const PLACEHOLDER_PATH: &str = "placeholder.png";

struct PendingAtlas {
    /// Strong handle to each texture that will eventually be added to the atlas.
    textures: Vec<Handle<Image>>,

    /// Strong handle that we will eventually populate with a built atlas texture.
    atlas_texture: Handle<Image>,

    /// Handle to the atlas layout that will be populated once building finishes.
    layout: Handle<TextureAtlasLayout>,
}

impl PendingAtlas {
    fn all_textures_loaded(&self, asset_server: &AssetServer) -> bool {
        self.textures
            .iter()
            .all(|handle| matches!(asset_server.get_load_state(handle), Some(LoadState::Loaded)))
    }
}

#[derive(Resource, Default)]
pub struct BlockTextures {
    /// Strong handle to a placeholder texture.
    pub placeholder_texture: Handle<Image>,

    /// Map from block state to texture handle.
    block_state_to_texture: HashMap<BlockStateId, Handle<Image>>,

    /// Texture atlases that have yet to be built because not all of the
    /// textures have loaded yet.
    pending_atlases: Vec<PendingAtlas>,

    /// Sources describing how textures map into a built atlas, keyed by the atlas handle.
    atlas_sources: HashMap<Handle<Image>, TextureAtlasSources>,
}

impl BlockTextures {
    /// Returns a handle to the texture for a provided block state, or a handle
    /// to a placeholder texture if that does not exist.
    pub fn get_or_load_texture<'a, F, P>(
        &mut self,
        block_state: BlockStateId,
        asset_server: &AssetServer,
        mut get_path: F,
    ) -> Handle<Image>
    where
        F: FnMut(BlockStateId) -> Option<P>,
        P: Into<AssetPath<'a>>,
    {
        match self.block_state_to_texture.entry(block_state) {
            Entry::Occupied(handle) => handle.get().clone(),
            Entry::Vacant(entry) => {
                let handle = get_path(block_state)
                    .map(|path| asset_server.load(path.into()))
                    .unwrap_or_else(|| {
                        debug!("No path found for {:?}", block_state);
                        self.placeholder_texture.clone()
                    });

                entry.insert(handle.clone());
                handle
            }
        }
    }

    pub fn create_texture_atlas_with_textures(
        &mut self,
        textures: impl IntoIterator<Item = Handle<Image>>,
        atlas_images: &mut Assets<Image>,
        atlas_layouts: &mut Assets<TextureAtlasLayout>,
    ) -> (Handle<Image>, Handle<TextureAtlasLayout>) {
        let atlas_texture = atlas_images.reserve_handle();
        let layout = atlas_layouts.reserve_handle();

        // The vended handle needs to be strong so that the atlas isn't dropped
        // as soon as it is added to the `Assets` in `finish_texture_atlases`.
        assert!(atlas_texture.is_strong());

        self.pending_atlases.push(PendingAtlas {
            textures: textures.into_iter().collect(),
            atlas_texture: atlas_texture.clone(),
            layout: layout.clone(),
        });

        (atlas_texture, layout)
    }

    /// Returns a handle to a [`TextureAtlas`] that includes the textures for
    /// all of the block states in `block_states`.
    ///
    /// If no such texture atlas exists yet, it will be generated by the plugin
    /// as soon as all of the required textures have been loaded.
    ///
    /// If any textures need to be loaded, the `asset_server` and `get_path`
    /// closure will be used to load them.
    pub fn create_texture_atlas<'a, B, F, P>(
        &mut self,
        block_states: B,
        asset_server: &AssetServer,
        mut get_path: F,
        atlas_images: &mut Assets<Image>,
        atlas_layouts: &mut Assets<TextureAtlasLayout>,
    ) -> (Handle<Image>, Handle<TextureAtlasLayout>)
    where
        B: IntoIterator<Item = BlockStateId>,
        F: FnMut(BlockStateId) -> Option<P>,
        P: Into<AssetPath<'a>>,
    {
        let mut block_states = block_states.into_iter().collect::<Vec<_>>();

        // Sort block states for determinism.
        block_states.sort_by_key(|block_state| block_state.0);

        debug!(
            "Texture atlas requested for block states: {:?}",
            block_states.iter().map(|b| b.0).collect::<Vec<_>>()
        );

        let textures = block_states
            .into_iter()
            .map(|block_state| self.get_or_load_texture(block_state, asset_server, &mut get_path))
            .collect::<Vec<_>>();

        self.create_texture_atlas_with_textures(textures, atlas_images, atlas_layouts)
    }

    /// Builds a [`TextureAtlas`] out of each [`PendingAtlas`] that is ready to
    /// be built, and inserts it into [`Assets<TextureAtlas>`].
    pub(crate) fn finish_texture_atlases(
        &mut self,
        asset_server: &AssetServer,
        atlas_layouts: &mut Assets<TextureAtlasLayout>,
        textures: &mut Assets<Image>,
    ) {
        if !matches!(
            asset_server.get_load_state(&self.placeholder_texture),
            Some(LoadState::Loaded)
        ) {
            return;
        }

        self.pending_atlases.retain(|pending_atlas| {
            if pending_atlas.all_textures_loaded(asset_server) {
                debug!(
                    "Building texture atlas for {} textures",
                    pending_atlas.textures.len()
                );

                let mut builder = TextureAtlasBuilder::default();

                for handle in pending_atlas.textures.iter() {
                    let source_handle = if textures.get(handle).is_some() {
                        handle
                    } else {
                        debug!("Texture not loaded, substituting placeholder: {:?}", handle);
                        &self.placeholder_texture
                    };

                    if let Some(texture) = textures.get(source_handle) {
                        builder.add_texture(Some(source_handle.id()), texture);
                    }
                }

                match builder.build() {
                    Ok((layout, sources, image)) => {
                        if let Err(err) = atlas_layouts.insert(pending_atlas.layout.id(), layout) {
                            error!("Failed to insert texture atlas layout: {err}");
                        }
                        if let Err(err) = textures.insert(pending_atlas.atlas_texture.id(), image) {
                            error!("Failed to insert texture atlas image: {err}");
                        }
                        self.atlas_sources
                            .insert(pending_atlas.atlas_texture.clone(), sources);
                        false
                    }
                    Err(err) => {
                        error!("Failed to build texture atlas: {err}");
                        true
                    }
                }
            } else {
                true
            }
        });
    }

    pub fn atlas_sources(&self, handle: &Handle<Image>) -> Option<&TextureAtlasSources> {
        self.atlas_sources.get(handle)
    }
}

/// Plugin that assembles texture atlases for voxel meshes.
pub struct TextureBuilderPlugin;

impl Plugin for TextureBuilderPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<BlockTextures>();
        app.add_systems(Startup, Self::load_placeholder_texture);
        app.add_systems(Update, Self::finish_texture_atlases);
    }
}

impl TextureBuilderPlugin {
    /// This system loads the placeholder texture at program startup.
    fn load_placeholder_texture(
        mut block_textures: ResMut<BlockTextures>,
        asset_server: Res<AssetServer>,
    ) {
        block_textures.placeholder_texture = asset_server.load(PLACEHOLDER_PATH);
    }

    /// This system calls [`BlockTextures::finish_texture_atlases`] once per
    /// frame to build texture atlases that are ready to be built.
    fn finish_texture_atlases(
        asset_server: Res<AssetServer>,
        mut block_textures: ResMut<BlockTextures>,
        mut atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
        mut textures: ResMut<Assets<Image>>,
    ) {
        block_textures.finish_texture_atlases(&asset_server, &mut atlas_layouts, &mut textures);
    }
}
